#+Title: Qute

* Using Qute 

** Simplest thing to do:  Beget objects

   This is from Crockfords definition of beget.[fn:1]  Beget will create a new object using the old object as its prototype.

#begin_src js :tangle no
var newObj = Qute.beget();
var newerObj = newObj.beget();
#+end_src

   ~newObj~ has the ~Qute~ object as its prototype, and ~newerObj~ has ~newObj~ and therefore ~Qute~ as it's prototype. 

** Extending objects with Extend

   In most cases you'll want to extend an object in the process of creating it.  This is done with the extend method:

#+begin_src js :tangle no
  var lawOfFives = Qute.extend({
      num: 5,
      why: "2 + 3 is 5.  It's the law of 5s!",
      printAwesomeNumber: function() {
          console.log (num+" is AWESOME.  Why?"+why);
      }
  });
  
  var skidoo = lawOfFives.extend({
      num: 6,
      why: "2 * 3 is 6." 
  });
    
  var powadoo = lawOfFives.extend({
      num: 8,
      why: "2 ^ 3 is 8." 
  });
#+end_src

   You can also pass multiple objects to extend.  Properties take precidence according to argument order, so for example:

#+begin_src js tangle: no
  
  var A = Qute.extend({
      a: 5,
      b: 6,
      c: 8
  });
  
  
  var B = A.extend({ a: 8}, { a: 7, z: 8}, {a: 9, w: 23, z: 88});
  
  console.log(B);
  /* -->
     {
       a: 8,
       b: 6,
       c: 8,
       w: 23
       z: 8
     }
  ,*/
#+end_src

** Rebinding -- or, how to avoid eating shit sandwiches.

   Sometimes you just have to eat shit... err.. use a Javascript
   library that binds this willy-nilly.  That sucks.  ~rebind~ lets
   you make sure that "this" says true to the current object, so you
   don't have to worry about errant event handlers.

#+begin_src js :tangle no
  var SomeHandlerObj = Qute.extend({
      init: function() {
          $poop('someDomSelector').on('click',this.rebind(this.click));
          $poop('someDomSelector').on('mouseEnter', this.rebind("enter"));
      },  
      click: function(e) {
          this.doStuff(e.target);
      },
      enter: function(e) {
          this.doStuff("STUFF!");
      }
      doStuff: function(things) {
          // ... etc ...
      }
  });
#+end_src

   The first syntax shows using rebind by passing in an arbitrary
   function.  A new function will be returned that will do stuff with
   the target...sorry...that willexecute the "click" function defined
   int he SomeHandlerObj with ~this~ bound to the SomeHandlerObj.  If
   you tried to define your handler without the rebind, the call
   ~this.doStufff~ would likely fail, as the $poop library likes to
   rebind ~this~.

   You can pass in any function that you want to rebind.  This would
   allow you to borrow methods from other functions, and makes for
   some interesting programming techniques. Try not to get too
   interesting however.

   Note, there already is a function in ECMA script that does what
   ~rebind~ does--unsurprisingly called ~bind~.  ~rebind~ is provided
   for compatibility.



* Qon2Dom (Quasi-Useful) Usage Example
** Status: Working, but needs more work.
#+begin_src js :tangle qon2dom.js
  Qon2Dom = Qute.extend({
      children: [],
      domReady:  function() {
          for(i=0; i< this.children.length; i++) {
              if (typeof this.children[i]["init"] == "function") {
                  this.children[i].init();
              } else {
                  throw "Cannot call init";
              }
          }
      },
      beget: function() {
          var o = Qute.beget(this);
          Qon2Dom.children.push(o);
          return o;
      },
      init: function() {}
  });
#+end_src
 

* Hacking Qute 

** TODO namespace!

** Base Object: Qute
*** TODO split this out using noweb
*** TODO when Function.bind is not available, it should work better. 
*** TODO extend should take an optional init function, rebind this, and execute it on completion.
#+begin_src js :tangle qute.js
  Qute = {
      beget: function() {
          function F() {};     
          F.prototype = this;  
          var o = new F();  // valid use of the new keyword here      
          return o;
      },
      extend: function() {  
          var o = this.beget();
          
          for (var i = arguments.length - 1; i >= 0; i--) {
              var from = arguments[i];
              for (var prop in from) { 
                  o[prop] = from[prop];
              }
          }
          return o; 
      },
      rebind: function(method) {
          if (typeof method == "string") {
              if (typeof this[method] == "function") {
                  method = this[method];
              } else {
                  throw "Cannot rebind "+method+".  Not bound to the current object.";
              }
          }
  
          if (typeof method["bind"] == "function") {
              return method.bind(this);
          } else {
              var self = this;
              return function() {
                  var args = Array.prototype.slice.call(arguments);
                  return method.apply(self, arguments);
              }
          }
      },
      quacksLike: function(duck) {
          var quacks = true;
          for (k in duck) {
              if (typeof this[k] == "undefined") {
                  quacks = false;
              }
          }
          return quacks;
      },
      quacksJustLike: function(duck) {
          var quacks = true;
          for (k in duck) {
              if ((typeof this[k] == "undefined") ||
                  (typeof this[k] == duck[k])){
                  quacks = false;
              }
          }
          return quacks;
  
      }
  };
#+end_src

*** TODO borrow ... figure out syntax

*** TODO proper testing


* Footnotes

[fn:1] http://javascript.crockford.com/prototypal.html
 
